<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3Dscan_measure v1.6（Rotate / Ground Height / Vertical Center / Capture Log）</title>
<style>
  :root{--bg:#0b0c0f;--panel:#14161acc;--fg:#e8e8ea;--mut:#9aa3b2;--hl:#47a3ff;--ok:#35d07f;--warn:#ffb31a}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,"Noto Sans JP",sans-serif}
  #toolbar{position:fixed;top:12px;left:12px;right:12px;z-index:20;display:flex;flex-wrap:wrap;gap:10px;align-items:center;background:var(--panel);backdrop-filter:blur(8px);padding:10px 12px;border-radius:12px}
  #toolbar input[type="range"]{width:140px}
  button{background:#1d232f;border:1px solid #2d3645;color:var(--fg);border-radius:10px;padding:8px 12px;cursor:pointer}
  button:hover{background:#253043}
  label{font-size:12px;color:var(--mut);display:flex;align-items:center;gap:6px}
  select{background:#1d232f;border:1px solid #2d3645;color:var(--fg);border-radius:10px;padding:6px 10px}
  #hud{position:fixed;right:12px;z-index:19;background:var(--panel);padding:8px 12px;border-radius:10px;font-size:12px;line-height:1.5;min-width:260px}
  #hint{position:fixed;left:12px;bottom:12px;z-index:19;background:var(--panel);padding:8px 12px;border-radius:10px;font-size:12px;color:var(--mut)}
  #drop{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;border:2px dashed #3a3f47;border-radius:16px;color:#aab;pointer-events:none;opacity:0;transition:.15s}
  #drop.show{opacity:1}
  canvas{display:block}
  .badge{display:inline-block;margin-left:6px;padding:2px 6px;border-radius:999px;background:#223049;border:1px solid #2d3c55;color:#cfe3ff;font-size:11px}

  #perimLabel,#caliperLabel{
    position:fixed; z-index:21; padding:6px 10px; border-radius:10px;
    background:var(--panel); border:1px solid #2d3c55; color:#eaf3ff;
    font-weight:700; font-size:13px; pointer-events:auto;
    transform:translate(-50%,-120%); box-shadow:0 6px 18px rgba(0,0,0,.25);
    opacity:.95; display:none; cursor:grab;
  }
  .dragging{cursor:grabbing!important}

  #logPanel{position:fixed;right:12px;top:calc(12px + 300px);z-index:22;
    background:var(--panel);border:1px solid #2d3c55;border-radius:10px;
    padding:10px;min-width:300px;max-width:420px;max-height:40vh;overflow:auto;font-size:12px;display:none}
  #logPanel header{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
  #logPanel ol{margin:0;padding-left:16px}
/* extra styles for export scale */
.miniRow{display:flex;gap:8px;align-items:center}
.miniRow input{width:80px}
</style>

<script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="toolbar">
  <input id="file" type="file" accept=".gltf,.glb,.obj" multiple />
  <button id="wireBtn">Wireframe: OFF</button><label>Wire color<input id="wireColor" type="color" value="#FFC857" title="ワイヤーの色（キャプチャ差別化用）"></label><label>Section line<input id="secColor" type="color" value="#47A3FF" title="断面ラインの色"></label><label>Selected<input id="selColor" type="color" value="#35D07F" title="選択中断面の色"></label>
  <button id="clipBtn">Clip Mesh: ON</button>

  <label>Nx<input id="nx" type="range" min="-1" max="1" step="0.01" value="0"></label>
  <label>Ny<input id="ny" type="range" min="-1" max="1" step="0.01" value="1"></label>
  <label>Nz<input id="nz" type="range" min="-1" max="1" step="0.01" value="0"></label>

  <label>Offset<input id="offset" type="range" min="-1" max="1" step="0.001" value="0"></label>
  <button id="off0Btn">Offset 0</button><button id="offMinusBtn">−</button><button id="offPlusBtn">＋</button>

  <label>Model unit
    <select id="modelUnitSel" title="このファイルの1 unit は何か？">
      <option value="auto" selected>auto</option>
      <option value="mm">mm</option>
      <option value="cm">cm</option>
      <option value="m">m</option>
      <option value="inch">inch</option>
    </select>
  </label>
  <label>Unit
    <select id="unitSel" title="表示単位（距離の見せ方）">
      <option value="mm">mm</option>
      <option value="cm" selected>cm</option>
      <option value="m">mt</option>
      <option value="inch">inch</option>
    </select>
  </label>

  <button id="rebuildBtn">Rebuild Section</button>
  <button id="resetBtn">Reset View</button>
  <button id="saveBtn">Save PNG</button>
  <button id="captureBtn" title="PNG保存＋ログ記録">Capture</button>
  <button id="caliperBtn">Caliper</button><div class="miniRow"><span style="color:#9aa3b2;font-size:12px">Export@Scale</span><label>mm/px <input id="expMmPerPx" type="number" min="0.01" step="0.01" value="1.00" title="1pxあたりのmm（固定スケール）"></label><label>W(px) <input id="expWpx" type="number" min="256" step="1" value="1200"></label><label>H(px) <input id="expHpx" type="number" min="256" step="1" value="1200"></label><label>Margin(px) <input id="expMargin" type="number" min="0" step="1" value="80"></label><button id="exportScaleBtn" title="固定スケール（オルソ）でPNG書き出し">Export @Scale</button></div>
  <button id="snapModeBtn">Snap: AUTO</button>

  <button id="alignYBtn">Align Y（水平）</button>
  <button id="alignXBtn">Align X（左右断面）</button>
  <button id="alignZBtn">Align Z（前後断面）</button>

  <button id="viewOnPlaneBtn" title="断面に正対＆フィット">View ⟂</button>
  <button id="flipViewBtn" title="上/下を切替">Flip View</button>
  <button id="upAxisBtn" title="画面の縦方向をU(前後)/V(左右)で切替">Up Axis: U</button>
  <button id="soloBtn" title="選択ポリライン＋計測のみ表示">Solo View: OFF</button>

  <button id="normalSnapBtn" title="最寄りの軸(X/Y/Z)へ90°スナップ">Normal: FREE</button>
  <button id="logToggleBtn" title="計測ログの表示/非表示">Log: OFF</button>

  <span class="badge">Seed: 2025-09-28-v1_6-capture-logs</span>

  <div class="sep"></div>
  <div class="row" style="display:flex;gap:8px;align-items:center">
    <span style="color:#9aa3b2;font-size:12px">Rotate</span>
    <button id="rotXm">X −90°</button>
    <button id="rotXp">X ＋90°</button>
    <button id="rotYm">Y −90°</button>
    <button id="rotYp">Y ＋90°</button>
    <button id="rotZm">Z −90°</button>
    <button id="rotZp">Z ＋90°</button>
    <button id="rotReset">Reset Rot</button>
  </div>

  <div class="row" style="display:flex;gap:8px;align-items:center">
    <label>Section
      <select id="sectionModeSel" title="断面タイプ">
        <option value="H" selected>水平（床）</option>
        <option value="VX">縦割り X（左右）</option>
        <option value="VZ">縦割り Z（前後）</option>
      </select>
    </label>
  </div>

  <div class="row" id="hRow" style="display:flex;gap:8px;align-items:center">
    <span style="color:#9aa3b2;font-size:12px">Ground</span>
    <button id="groundBtn" title="BBoxの最小Yを底面に採用">底面検出</button>
    <label>Height(mm)<input id="heightMm" style="width:96px" type="number" step="1" value="900"></label>
    <button id="applyHeightBtn">適用</button>
  </div>

  <div class="row" id="vRow" style="display:none;gap:8px;align-items:center">
    <label>中心から距離(mm)<input id="vOffsetMm" style="width:96px" type="number" step="1" value="0"></label>
    <button id="applyVBtn">適用</button>
  </div>
</div>

<div id="hud">周長: —<br>閉ループ: —<br>点‐点: —<br>縦横(平面U/V)距離(Shift): —<br>Offset実距離: —<br>幅(V:左右) / 厚み(U:前後): —</div>
<div id="hint">
  読込 → <b>Rotate</b>で正位置 → <b>Section</b>選択 → <b>Height/距離</b>入力 → <b>View ⟂</b> → PNG/CSV。<br>
  水平＝底面（BBox MinY）からの高さ、縦割り＝オブジェクト中心からの距離。タグはドラッグで移動、ダブルクリックでリセット。
</div>
<div id="drop"><div>ここに .glb / .gltf / .obj をドロップ（複数可：体＋衣装）</div></div>
<canvas id="c"></canvas>
<div id="perimLabel"></div>
<div id="caliperLabel"></div>

<div id="logPanel">
  <header><strong>計測ログ</strong><span><button id="logCsvBtn">CSV</button> <button id="logClearBtn">クリア</button></span></header>
  <ol id="logList"></ol>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { OBJLoader } from "three/addons/loaders/OBJLoader.js";

/* ===== 基本セットアップ ===== */
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, preserveDrawingBuffer:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0b0c0f, 1);
renderer.localClippingEnabled = true;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.01, 5000);
camera.position.set(0.6, 0.6, 1.2);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ホームビュー */
const home = { pos:new THREE.Vector3(), target:new THREE.Vector3(), up:new THREE.Vector3(0,1,0) };
function saveHomeFromCurrent(){ home.pos.copy(camera.position); home.target.copy(controls.target); home.up.copy(camera.up); }
function resetToHome(){ camera.position.copy(home.pos); camera.up.copy(home.up); controls.target.copy(home.target); camera.updateProjectionMatrix(); controls.update(); }

/* 環境 */
scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.9));
const key = new THREE.DirectionalLight(0xffffff, 0.85); key.position.set(1.2,1.2,1.2); scene.add(key);
const grid = new THREE.GridHelper(2, 20, 0x2a2f38, 0x1a1d24); grid.position.y = -0.001; scene.add(grid);

/* 断面平面 */
const clippingPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
const planeHelper = new THREE.PlaneHelper(clippingPlane, 1, 0x47a3ff); scene.add(planeHelper);

let root = new THREE.Group(); scene.add(root);
let loadedMeshes = [];
let isWire = false, clipEnabled = true;

let sectionGroup = new THREE.Group(); scene.add(sectionGroup);
let sectionPolylines = []; let selectedPolyline = null; let selectedPerimeterRaw = null;

const overlayGroup = new THREE.Group(); scene.add(overlayGroup);
const caliperGroup = new THREE.Group(); scene.add(caliperGroup);

/* UI要素 */
const toolbar = document.getElementById("toolbar");
const hud = document.getElementById("hud");
const perimLabel = document.getElementById("perimLabel");
const caliperLabel = document.getElementById("caliperLabel");
const unitSel = document.getElementById("unitSel");
const modelUnitSel = document.getElementById("modelUnitSel");
const $nx = document.getElementById("nx");
const $ny = document.getElementById("ny");
const $nz = document.getElementById("nz");
const $offset = document.getElementById("offset");

/* 新規 UI要素 */
const sectionModeSel = document.getElementById("sectionModeSel");
const hRow = document.getElementById("hRow");
const vRow = document.getElementById("vRow");
const groundBtn = document.getElementById("groundBtn");
const heightMm = document.getElementById("heightMm");
const applyHeightBtn = document.getElementById("applyHeightBtn");
const vOffsetMm = document.getElementById("vOffsetMm");
const applyVBtn = document.getElementById("applyVBtn");

/* 状態 */
let bboxSize = 1, bboxCenter = new THREE.Vector3(0,0,0), bboxMin = new THREE.Vector3(0,0,0), offsetScale = 1.0;
let lastOffsetReal = null;
let viewSide = +1;
let upAxis = "u";
let soloMode = false;
let snapMode = "auto";
let normalSnap = "FREE"; // FREE / AXIS
let groundY = 0; // BBox MinY

/* ===== 単位換算 ===== */
let autoModelUnitToCmGuess = 1.0;
function modelUnitToCm(){ const v=modelUnitSel.value; if(v==="mm")return .1; if(v==="cm")return 1; if(v==="m")return 100; if(v==="inch")return 2.54; return autoModelUnitToCmGuess; }
function displayFactorFromCm(){ switch(unitSel.value){ case "mm":return 10; case "cm":return 1; case "m":return .01; case "inch":return 1/2.54; default:return 1; } }
function unitSuffix(){ return (unitSel.value==="inch")?"in":(unitSel.value==="m"?"mt":unitSel.value); }
function toDisplay(dModelUnits){ return dModelUnits * modelUnitToCm() * displayFactorFromCm(); }
function mmToModel(mm){ return (mm/10) / modelUnitToCm(); } // mm -> model units

/* ===== Utils ===== */
function lengthOfPolyline(pts, closed){ if(!pts||pts.length<2) return 0; let L=0; for(let i=0;i<pts.length-1;i++) L+=pts[i].distanceTo(pts[i+1]); if(closed) L+=pts.at(-1).distanceTo(pts[0]); return L; }
function polylineCentroid(pts){ const c=new THREE.Vector3(); for(const p of pts) c.add(p); return c.multiplyScalar(1/pts.length); }
function worldToScreen(v){ const p=v.clone().project(camera); return [(p.x*0.5+0.5)*innerWidth, (-p.y*0.5+0.5)*innerHeight]; }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

/* ===== HUD / ラベル：ヘッダー下に自動退避 & 画面内クランプ ===== */
function safeTop(){ return toolbar.getBoundingClientRect().bottom + 8; }
function setHUDTop(){ hud.style.top = safeTop()+"px"; }
function clampLabelXY(x,y){
  const marginX = 80, marginBottom = 40;
  const xClamped = clamp(x, marginX, innerWidth - marginX);
  const yClamped = clamp(y, safeTop()+12, innerHeight - marginBottom);
  return [xClamped, yClamped];
}
let perimOffset = {dx:0,dy:0}, caliperOffset = {dx:0,dy:0};
try{ const saved=JSON.parse(localStorage.getItem("v1_6_tagOffsets")||"{}"); if(saved.perimOffset) perimOffset=saved.perimOffset; if(saved.caliperOffset) caliperOffset=saved.caliperOffset; }catch{}
function persistTagOffsets(){ try{localStorage.setItem("v1_6_tagOffsets", JSON.stringify({perimOffset,caliperOffset}));}catch{} }
function updatePerimLabelText(){ if(selectedPolyline&&selectedPerimeterRaw!=null){ perimLabel.textContent=`周長 ${toDisplay(selectedPerimeterRaw).toFixed(2)} ${unitSuffix()}`; perimLabel.style.display="block"; } else perimLabel.style.display="none"; }
function updatePerimLabelPosition(){ if(selectedPolyline?.points?.length){ let [x,y]=worldToScreen(polylineCentroid(selectedPolyline.points)); [x,y]=clampLabelXY(x+perimOffset.dx,y+perimOffset.dy); perimLabel.style.left=`${x}px`; perimLabel.style.top=`${y}px`; } }
let caliperWU=null, caliperDV=null;
function updateCaliperLabel(){ if(caliperWU!=null&&caliperDV!=null){ caliperLabel.textContent=`幅(V:左右) ${toDisplay(caliperWU).toFixed(2)} ${unitSuffix()} / 厚み(U:前後) ${toDisplay(caliperDV).toFixed(2)} ${unitSuffix()}`; caliperLabel.style.display="block"; } else caliperLabel.style.display="none"; }
function updateCaliperLabelPosition(){ if(selectedPolyline?.points?.length){ let [x,y]=worldToScreen(polylineCentroid(selectedPolyline.points)); [x,y]=clampLabelXY(x+caliperOffset.dx,y+22+caliperOffset.dy); caliperLabel.style.left=`${x}px`; caliperLabel.style.top=`${y}px`; } }
perimLabel.addEventListener("mousedown",e=>{ perimLabel.classList.add("dragging"); const sx=e.clientX, sy=e.clientY; const ox=perimOffset.dx, oy=perimOffset.dy; const onMove=(ev)=>{ perimOffset.dx=ox+(ev.clientX-sx); perimOffset.dy=oy+(ev.clientY-sy); persistTagOffsets(); updatePerimLabelPosition(); }; const onUp=()=>{ perimLabel.classList.remove("dragging"); removeEventListener("mousemove",onMove); removeEventListener("mouseup",onUp); }; addEventListener("mousemove",onMove); addEventListener("mouseup",onUp); });
caliperLabel.addEventListener("mousedown",e=>{ caliperLabel.classList.add("dragging"); const sx=e.clientX, sy=e.clientY; const ox=caliperOffset.dx, oy=caliperOffset.dy; const onMove=(ev)=>{ caliperOffset.dx=ox+(ev.clientX-sx); caliperOffset.dy=oy+(ev.clientY-sy); persistTagOffsets(); updateCaliperLabelPosition(); }; const onUp=()=>{ caliperLabel.classList.remove("dragging"); removeEventListener("mousemove",onMove); removeEventListener("mouseup",onUp); }; addEventListener("mousemove",onMove); addEventListener("mouseup",onUp); });
perimLabel.addEventListener("dblclick",()=>{ perimOffset={dx:0,dy:0}; persistTagOffsets(); updatePerimLabelPosition(); });
caliperLabel.addEventListener("dblclick",()=>{ caliperOffset={dx:0,dy:0}; persistTagOffsets(); updateCaliperLabelPosition(); });

function updateHUD(distPP, distAxis, offsetReal){
  if(offsetReal!==undefined) lastOffsetReal=offsetReal;
  const u=unitSuffix();
  const perimVal=(selectedPerimeterRaw!=null)?`${toDisplay(selectedPerimeterRaw).toFixed(2)} ${u}`:"—";
  const closed=selectedPolyline?(selectedPolyline.closed?"はい":"いいえ"):"—";
  const d=distPP!=null?`${toDisplay(distPP).toFixed(2)} ${u}`:"—";
  const a=distAxis!=null?`${toDisplay(distAxis).toFixed(2)} ${u}`:"—";
  const off=(lastOffsetReal!=null)?`${toDisplay(lastOffsetReal).toFixed(2)} ${u}`:"—";
  const cal=(caliperWU!=null&&caliperDV!=null)?`${toDisplay(caliperWU).toFixed(2)} / ${toDisplay(caliperDV).toFixed(2)} ${u}`:"—";
  hud.innerHTML=`周長: ${perimVal}<br>閉ループ: ${closed}<br>点‐点: ${d}<br>縦横(平面U/V)距離(Shift): ${a}<br>Offset実距離: ${off}<br>幅(V:左右) / 厚み(U:前後): ${cal}`;
  updatePerimLabelText(); updatePerimLabelPosition();
  updateCaliperLabel(); updateCaliperLabelPosition();
  setHUDTop();
}


/* ==== Wireframe color (custom material swap) ==== */
const wireColorInput = document.getElementById("wireColor");
function makeWireMat(){ return new THREE.MeshBasicMaterial({color:new THREE.Color(wireColorInput.value), wireframe:true}); }
function setWireframe(flag){
  isWire = flag;
  document.getElementById("wireBtn").textContent = "Wireframe: " + (isWire?"ON":"OFF");
  root.traverse(o=>{
    if(!o.isMesh) return;
    if(flag){
      if(o.userData._origMat===undefined){ o.userData._origMat = o.material; }
      o.material = makeWireMat();
    }else{
      if(o.userData._origMat!==undefined){ o.material = o.userData._origMat; delete o.userData._origMat; }
      else if(o.material?.wireframe){ o.material.wireframe=false; }
    }
    o.material.needsUpdate = true;
  });
}
wireColorInput.addEventListener("input", ()=>{ if(isWire) setWireframe(true); });


/* ==== Section polyline colors ==== */
const secColorInput = document.getElementById("secColor");
const selColorInput = document.getElementById("selColor");
(function restoreLineColors(){
  try{
    const s = JSON.parse(localStorage.getItem("v1_6_linecolors")||"{}");
    if(s.sec) secColorInput.value = s.sec;
    if(s.sel) selColorInput.value = s.sel;
  }catch{}
})();
function persistLineColors(){
  try{ localStorage.setItem("v1_6_linecolors", JSON.stringify({sec:secColorInput.value, sel:selColorInput.value})); }catch{}
}
function applySectionLineColors(){
  const normal = new THREE.Color(secColorInput.value);
  const selected = new THREE.Color(selColorInput.value);
  for(const p of sectionPolylines){
    if(p===selectedPolyline) p.line.material.color.copy(selected);
    else p.line.material.color.copy(normal);
    p.line.material.needsUpdate = true;
  }
}
secColorInput.addEventListener("input", ()=>{ persistLineColors(); applySectionLineColors(); });
selColorInput.addEventListener("input", ()=>{ persistLineColors(); applySectionLineColors(); });

/* ===== メッシュ管理 ===== */
function applyWireframe(target, flag){ target.traverse(o=>{ if(o.isMesh && o.material){ (Array.isArray(o.material)?o.material:[o.material]).forEach(m=>{ m.wireframe=flag; m.needsUpdate=true; }); }}); }
function applyClippingToMeshes(enabled){
  root.traverse(o=>{ if(o.isMesh&&o.material){ (Array.isArray(o.material)?o.material:[o.material]).forEach(m=>{ m.clippingPlanes=enabled?[clippingPlane]:null; m.clipIntersection=false; m.needsUpdate=true; }); }});
}
function applySoloMode(flag){
  soloMode = flag;
  root.visible = !flag; grid.visible = !flag; planeHelper.visible = !flag;
  for(const p of sectionPolylines){ p.line.visible = !flag ? true : (p===selectedPolyline); }
}
function collectMeshes(node){ loadedMeshes.length=0; node.traverse(o=>{ if(o.isMesh&&o.geometry?.isBufferGeometry){ loadedMeshes.push(o); o.castShadow=o.receiveShadow=true; }}); }

/* fitView */
function fitView(object3D){
  const box=new THREE.Box3().setFromObject(object3D);
  if(!box.isEmpty()){
    const size=box.getSize(new THREE.Vector3());
    bboxCenter.copy(box.getCenter(new THREE.Vector3()));
    bboxMin.copy(box.min);
    bboxSize=Math.max(size.x,size.y,size.z);

    controls.target.copy(bboxCenter);
    camera.position.copy(bboxCenter).add(new THREE.Vector3(bboxSize*1.2,bboxSize*1.2,bboxSize*1.2));
    camera.near=Math.max(bboxSize/1000,0.001); camera.far=bboxSize*20;
    camera.up.set(0,1,0); camera.updateProjectionMatrix(); controls.update();

    saveHomeFromCurrent();

    planeHelper.size=bboxSize*1.5;
    raycaster.params.Line.threshold=bboxSize*0.015;
    offsetScale=bboxSize*0.8; $offset.value="0";

    applyClippingToMeshes(clipEnabled);
    groundY = bboxMin.y; // 底面更新
    updatePlane();
  }
}

function clearRoot(){ while(root.children.length) root.remove(root.children[0]); loadedMeshes.length=0; }
function clearSections(){ while(sectionGroup.children.length) sectionGroup.remove(sectionGroup.children[0]); sectionPolylines.length=0; selectedPolyline=null; selectedPerimeterRaw=null; updateHUD(); }
function clearOverlay(){ while(overlayGroup.children.length) overlayGroup.remove(overlayGroup.children[0]); while(caliperGroup.children.length) caliperGroup.remove(caliperGroup.children[0]); caliperWU=caliperDV=null; updateHUD(); }

/* 読み込み */
function loadSingle(url,ext,done){
  if (modelUnitSel.value === "auto") {
    if (ext === "gltf" || ext === "glb") autoModelUnitToCmGuess = 100.0;
    else if (ext === "obj")              autoModelUnitToCmGuess = 1.0;
    else                                 autoModelUnitToCmGuess = 1.0;
  }
  if(ext==="glb"||ext==="gltf"){
    new GLTFLoader().load(url,(g)=>{ root.add(g.scene); collectMeshes(g.scene); done(); },undefined,done);
  }else if(ext==="obj"){
    new OBJLoader().load(url,(o)=>{ o.traverse(ch=>{ if(ch.isMesh){ if(!ch.material){ ch.material=new THREE.MeshPhongMaterial({color:0x808080,side:THREE.DoubleSide}); } else { ch.material.side=THREE.DoubleSide; } }}); root.add(o); collectMeshes(o); done(); },undefined,done);
  }else{ done(); }
}
document.getElementById("file").addEventListener("change",e=>{
  const files=Array.from(e.target.files||[]); if(!files.length) return;
  clearRoot(); clearSections(); clearOverlay(); applySoloMode(false);
  let pending=files.length; const done=()=>{ if(--pending===0){ fitView(root); applySectionFromUI(); if(isWire) setWireframe(true); } };
  files.forEach(f=>{ const url=URL.createObjectURL(f); const ext=f.name.toLowerCase().split('.').pop(); loadSingle(url,ext,done); });
});

/* ===== 断面生成 ===== */
function stitchSegments(segs,eps){
  const key=v=>`${Math.round(v.x/eps)},${Math.round(v.y/eps)},${Math.round(v.z/eps)}`;
  const map=new Map(); const add=(p,q)=>{ const k=key(p); if(!map.has(k)) map.set(k,[]); map.get(k).push(q); };
  for(const s of segs){ add(s.a,s.b); add(s.b,s.a); }
  const used=new Set(), polylines=[];
  function nextPoint(p){ const ks=key(p), arr=map.get(ks)||[]; for(const q of arr){ const e=ks+"|"+key(q); if(!used.has(e)){ used.add(e); used.add(key(q)+"|"+ks); return q; } } return null; }
  for(const s of segs){
    const e0=key(s.a)+"|"+key(s.b); if(used.has(e0)) continue;
    const poly=[s.a.clone(), s.b.clone()]; used.add(e0); used.add(key(s.b)+"|"+key(s.a));
    while(true){ const last=poly.at(-1); const nxt=nextPoint(last); if(!nxt) break; poly.push(nxt.clone()); }
    while(true){ const first=poly[0]; const nxt=nextPoint(first); if(!nxt) break; poly.unshift(nxt.clone()); }
    const closed = poly[0].distanceTo(poly.at(-1)) < eps*2;
    polylines.push({points:poly,closed});
  }
  return polylines;
}
function rebuildSection(){
  clearSections(); clearOverlay();
  if(!loadedMeshes.length) return;
  const n=clippingPlane.normal.clone(), c=clippingPlane.constant;
  const segs=[]; const eps=Math.max(1e-6,bboxSize*1e-6), mergeEps=Math.max(1e-5,bboxSize*1e-5);
  const vA=new THREE.Vector3(), vB=new THREE.Vector3(), vC=new THREE.Vector3(), _world=new THREE.Matrix4();
  const planeSide=(p)=>n.dot(p)+c;
  const lerpOnPlane=(p0,p1,s0,s1)=>{ const t=s0/(s0-s1); return p0.clone().lerp(p1,t); };

  for(const mesh of loadedMeshes){
    const geom=mesh.geometry, pos=geom.getAttribute('position'); if(!pos) continue;
    _world.copy(mesh.matrixWorld);
    const idx=geom.index?geom.index.array:null;
    const tri=idx?(idx.length/3):(pos.count/3);
    const isSkinned=mesh.isSkinnedMesh===true && mesh.skeleton; if(isSkinned) mesh.skeleton.update();
    const getV=(i,out)=>{ if(isSkinned){ mesh.boneTransform(i,out); out.applyMatrix4(mesh.matrixWorld);} else { out.fromBufferAttribute(pos,i).applyMatrix4(_world);} return out; };

    for(let i=0;i<tri;i++){
      const ia=idx?idx[i*3]:i*3, ib=idx?idx[i*3+1]:i*3+1, ic=idx?idx[i*3+2]:i*3+2;
      getV(ia,vA); getV(ib,vB); getV(ic,vC);
      const sa=planeSide(vA), sb=planeSide(vB), sc=planeSide(vC);
      if((sa>0&&sb>0&&sc>0)||(sa<0&&sb<0&&sc<0)) continue;
      const pts=[]; const edge=(p0,p1,s0,s1)=>{ if((s0>0&&s1<0)||(s0<0&&s1>0)) pts.push(lerpOnPlane(p0,p1,s0,s1)); else if(Math.abs(s0)<eps) pts.push(p0.clone()); else if(Math.abs(s1)<eps) pts.push(p1.clone()); };
      edge(vA,vB,sa,sb); edge(vB,vC,sb,sc); edge(vC,vA,sc,sa);
      if(pts.length===2) segs.push({a:pts[0],b:pts[1]});
      else if(pts.length>2){
        let max=-1, pa=pts[0], pb=pts[1];
        for(let u=0; u<pts.length; u++){
          for(let v=u+1; v<pts.length; v++){
            const d=pts[u].distanceToSquared(pts[v]);
            if(d>max){ max=d; pa=pts[u]; pb=pts[v]; }
          }
        }
        segs.push({a:pa,b:pb});
      }
    }
  }

  const polylines=stitchSegments(segs,mergeEps);
  for(const {points,closed} of polylines){
    const geo=new THREE.BufferGeometry().setFromPoints(points);
    const line=new THREE.Line(geo,new THREE.LineBasicMaterial({color:new THREE.Color(document.getElementById("secColor").value)}));
    line.userData.points=points; sectionGroup.add(line);
    sectionPolylines.push({points,line,closed});
  }
  sectionGroup.traverse(o=>{ if(o.isLine) o.raycast=THREE.Line.prototype.raycast; });

  if(sectionPolylines.length){
    selectedPolyline = sectionPolylines.slice().sort((a,b)=>lengthOfPolyline(b.points,b.closed)-lengthOfPolyline(a.points,a.closed))[0];
    selectedPerimeterRaw = lengthOfPolyline(selectedPolyline.points, selectedPolyline.closed);
    highlightSelection(selectedPolyline);
    updatePerimLabelText(); updatePerimLabelPosition();
    if(soloMode){ applySoloMode(true); }
  } else { selectedPolyline=null; selectedPerimeterRaw=null; }
  applySectionLineColors();
  updateHUD();
}
function highlightSelection(sel){
  const normal = new THREE.Color(document.getElementById('secColor').value);
  const selected = new THREE.Color(document.getElementById('selColor').value);
  for(const p of sectionPolylines){ p.line.material.color.copy(normal); p.line.visible = !soloMode ? true : (p===sel); }
  if(sel) sel.line.material.color.copy(selected);
  applySectionLineColors();
  updateHUD();
}

/* ===== 計測 & Caliper ===== */
const raycaster = new THREE.Raycaster(); raycaster.params.Line={threshold:0.01};
let pickA=null;

function planeBasisFromNormal(n){
  const tmp=Math.abs(n.y)<0.9?new THREE.Vector3(0,1,0):new THREE.Vector3(1,0,0);
  const u=tmp.clone().cross(n).normalize();
  const v=n.clone().cross(u).normalize();
  return {u,v};
}
function nearestPointOnPolylineScreen(ev,pts){
  const rect=renderer.domElement.getBoundingClientRect();
  const mx=ev.clientX-rect.left, my=ev.clientY-rect.top;
  let best=pts[0].clone(), bestD2=Infinity;
  for(let i=0;i<pts.length-1;i++){
    const a=pts[i].clone(), b=pts[i+1].clone();
    const ap=a.clone().project(camera), bp=b.clone().project(camera);
    const ax=(ap.x*0.5+0.5)*rect.width, ay=(-ap.y*0.5+0.5)*rect.height;
    const bx=(bp.x*0.5+0.5)*rect.width, by=(-bp.y*0.5+0.5)*rect.height;
    const abx=bx-ax, aby=by-ay; const denom=abx*abx+aby*aby||1;
    const t=THREE.MathUtils.clamp(((mx-ax)*abx+(my-ay)*aby)/denom,0,1);
    const d2=(mx-(ax+abx*t))**2+(my-(ay*1+aby*t))**2;
    if(d2<bestD2){ bestD2=d2; best.copy(a.clone().lerp(b,t)); }
  }
  return best;
}
function clearPicks(){ while(overlayGroup.children.length) overlayGroup.remove(overlayGroup.children[0]); pickA = null; updateHUD(); }
function drawPick(p){ const g=new THREE.SphereGeometry(bboxSize*(0.004/3),12,12); const m=new THREE.MeshBasicMaterial({color:0xffffff}); const s=new THREE.Mesh(g,m); s.position.copy(p); overlayGroup.add(s); if(overlayGroup.children.length>60) overlayGroup.remove(overlayGroup.children[0]); }
function drawLine(a,b,color,dashed=true){ const geo=new THREE.BufferGeometry().setFromPoints([a,b]); const mat=dashed?new THREE.LineDashedMaterial({color,dashSize:bboxSize*0.02,gapSize:bboxSize*0.02}):new THREE.LineBasicMaterial({color}); const line=new THREE.Line(geo,mat); if(dashed) line.computeLineDistances(); overlayGroup.add(line); if(overlayGroup.children.length>80) overlayGroup.remove(overlayGroup.children[0]); }

function onPointerDown(ev){
  const rect = renderer.domElement.getBoundingClientRect();
  const mouse = new THREE.Vector2(((ev.clientX-rect.left)/rect.width)*2-1, -((ev.clientY-rect.top)/rect.height)*2+1);
  raycaster.setFromCamera(mouse, camera);

  const lines=[]; sectionGroup.traverse(o=>{ if(o.isLine) lines.push(o); });
  const hit = raycaster.intersectObjects(lines, false)[0];

  if (hit){
    const poly = sectionPolylines.find(p => p.line === hit.object);
    if (!poly) return;

    if (poly !== selectedPolyline){
      selectedPolyline     = poly;
      selectedPerimeterRaw = lengthOfPolyline(poly.points, poly.closed);
      highlightSelection(poly);
      updatePerimLabelText(); updatePerimLabelPosition();
      clearPicks();
      return;
    }

    const closest = nearestPointOnPolylineScreen(ev, poly.points);
    if (pickA === null){ pickA = closest.clone(); drawPick(pickA); }
    else { handleMeasurePoint(closest, ev.shiftKey); }
    return;
  }
  clearPicks();
}
function handleMeasurePoint(p,shift){
  if(!p||!pickA) return;
  const pickB=p.clone(); drawPick(pickB);
  let distPP=pickA.distanceTo(pickB), distAxis=null;
  if(shift && snapMode!=="off"){
    const {u,v}=planeBasisFromNormal(clippingPlane.normal);
    const du=(pickB.clone().sub(pickA)).dot(u), dv=(pickB.clone().sub(pickA)).dot(v);
    let locked;
    if(snapMode==="u"){ locked=pickA.clone().add(u.clone().multiplyScalar(du)); distAxis=Math.abs(du); }
    else if(snapMode==="v"){ locked=pickA.clone().add(v.clone().multiplyScalar(dv)); distAxis=Math.abs(dv); }
    else { if(Math.abs(du)>=Math.abs(dv)){ locked=pickA.clone().add(u.clone().multiplyScalar(du)); distAxis=Math.abs(du); } else { locked=pickA.clone().add(v.clone().multiplyScalar(dv)); distAxis=Math.abs(dv); } }
    drawLine(pickA,locked,0xffb31a);
  } else { drawLine(pickA,pickB,0xffffff); }
  updateHUD(distPP,distAxis); pickA=null;
}

/* === Caliper === */
function computeCalipers(){
  if(!selectedPolyline) return;
  while(caliperGroup.children.length) caliperGroup.remove(caliperGroup.children[0]);
  caliperWU=caliperDV=null;

  const pts=selectedPolyline.points, center=polylineCentroid(pts);
  const {u:U,v:V}=planeBasisFromNormal(clippingPlane.normal);
  const wPts=pts.map(p=>p.clone());
  const uv=wPts.map(p=>{ const d=p.clone().sub(center); return {u:d.dot(U), v:d.dot(V)}; });

  function intersectAxis(getA,getB){
    const hits=[];
    for(let i=0;i<uv.length-1;i++){
      const a=uv[i], b=uv[i+1], A0=getA(a), A1=getA(b), B0=getB(a), B1=getB(b);
      if((B0===0)||(B1===0)||((B0>0)!==(B1>0))){
        const denom=(B0-B1), t=(Math.abs(denom)<1e-12)?0:(B0/(B0-B1));
        const tC=THREE.MathUtils.clamp(t,0,1);
        hits.push({coord:A0+(A1-A0)*tC, PW:wPts[i].clone().lerp(wPts[i+1],tC)});
      }
    }
    if(hits.length<2) return null;
    hits.sort((h1,h2)=>h1.coord-h2.coord);
    return {min:hits[0], max:hits.at(-1)};
  }
  const Ures=intersectAxis(h=>h.u, h=>h.v);
  const Vres=intersectAxis(h=>h.v, h=>h.u);

  if(Ures){ const a=Ures.min.PW, b=Ures.max.PW; caliperDV=a.distanceTo(b); drawCaliper(a,b,0x9ad1ff); }
  if(Vres){ const a=Vres.min.PW, b=Vres.max.PW; caliperWU=a.distanceTo(b); drawCaliper(a,b,0x9affbf); }
  applySectionLineColors();
  updateHUD();
}
function drawCaliper(a,b,color){
  const geo=new THREE.BufferGeometry().setFromPoints([a,b]);
  const line=new THREE.Line(geo,new THREE.LineBasicMaterial({color}));
  caliperGroup.add(line);
  const r=bboxSize*(0.005/3), sph=new THREE.SphereGeometry(r,12,12), m=new THREE.MeshBasicMaterial({color});
  const s1=new THREE.Mesh(sph,m); s1.position.copy(a);
  const s2=new THREE.Mesh(sph,m); s2.position.copy(b);
  caliperGroup.add(s1,s2);
}

/* ===== 平面更新 & 法線スナップ ===== */
function applyNormalSnap(n){
  if(normalSnap!=="AXIS") return n.normalize();
  const ax=Math.abs(n.x), ay=Math.abs(n.y), az=Math.abs(n.z);
  if(ax>=ay && ax>=az) return new THREE.Vector3(Math.sign(n.x)||1,0,0);
  if(ay>=ax && ay>=az) return new THREE.Vector3(0,Math.sign(n.y)||1,0);
  return new THREE.Vector3(0,0,Math.sign(n.z)||1);
}
function updatePlane(){
  let n=new THREE.Vector3(parseFloat($nx.value),parseFloat($ny.value),parseFloat($nz.value));
  if(n.lengthSq()<1e-6) n.set(0,1,0);
  n = applyNormalSnap(n).normalize();
  $nx.value = n.x.toFixed(2); $ny.value = n.y.toFixed(2); $nz.value = n.z.toFixed(2);

  const offVal=parseFloat($offset.value)||0;
  const offReal=offVal*offsetScale;
  const c = - n.dot(bboxCenter.clone().add(n.clone().multiplyScalar(offReal)));
  clippingPlane.normal.copy(n);
  clippingPlane.constant=c;

  planeHelper.plane=clippingPlane; planeHelper.updateMatrixWorld(true);
  if(clipEnabled) applyClippingToMeshes(true);
  rebuildSection();
  updateHUD(undefined,undefined,offReal);
}
function setNormalExact(x,y,z){ $nx.value=String(x); $ny.value=String(y); $nz.value=String(z); updatePlane(); }
function offsetStep(val){ const cur=parseFloat($offset.value)||0; $offset.value=clamp(cur+val,-1,1).toFixed(3); updatePlane(); }

/* ===== 断面正対ビュー ===== */
function polyCenter(){ return selectedPolyline?.points?.length ? polylineCentroid(selectedPolyline.points) : bboxCenter.clone(); }
function alignViewToPlane(){
  let center = polyCenter();
  const n = clippingPlane.normal.clone().normalize();
  const {u:U0, v:V0} = planeBasisFromNormal(n);
  let U = U0.clone(), V = V0.clone();

  let upVec = (upAxis==="u") ? U.clone() : V.clone();
  if (upVec.dot(new THREE.Vector3(0,1,0)) < 0){ upVec.multiplyScalar(-1); }

  let minU=Infinity,maxU=-Infinity,minV=Infinity,maxV=-Infinity;
  const pts = selectedPolyline?.points || []; const c = center.clone();
  if(pts.length){
    for(const p of pts){
      const d = p.clone().sub(c);
      const u = d.dot(U), v = d.dot(V);
      if(u<minU) minU=u; if(u>maxU) maxU=u;
      if(v<minV) minV=v; if(v>maxV) maxV=v;
    }
  }else{ minU=minV=-bboxSize*0.25; maxU=maxV=bboxSize*0.25; }

  const halfU=(maxU-minU)/2, halfV=(maxV-minV)/2;
  const vfov = camera.fov * Math.PI/180;
  const distV = (upAxis==="u" ? halfU : halfV) / Math.tan(vfov/2);
  const distH = (upAxis==="u" ? halfV : halfU) / (Math.tan(vfov/2) * camera.aspect);
  const dist  = Math.max(distV, distH) * 1.25 + 1e-6;

  const dir = n.clone().multiplyScalar(viewSide);
  camera.position.copy(center).add(dir.multiplyScalar(dist));
  camera.up.copy(upVec);
  controls.target.copy(center);
  camera.lookAt(center);
  controls.update();
}

/* ===== 水平/縦割りの絶対入力 ===== */
function setOffsetForPlanePassingThrough(n, P0){
  const offReal = P0.clone().sub(bboxCenter).dot(n); // amount along n from bboxCenter
  $nx.value = n.x.toFixed(2); $ny.value = n.y.toFixed(2); $nz.value = n.z.toFixed(2);
  $offset.value = clamp(offReal / offsetScale, -1, 1).toFixed(3);
  updatePlane();
}
function setHorizontalByHeightMm(hmm){
  const n = new THREE.Vector3(0,1,0);
  const y = groundY + mmToModel(parseFloat(hmm)||0);
  const P0 = new THREE.Vector3(bboxCenter.x, y, bboxCenter.z);
  setOffsetForPlanePassingThrough(n, P0);
}
function setVerticalByOffsetMm(axis, dmm){
  let n;
  if(axis==="x") n = new THREE.Vector3(1,0,0);
  else if(axis==="z") n = new THREE.Vector3(0,0,1);
  else n = new THREE.Vector3(1,0,0);
  const d = mmToModel(parseFloat(dmm)||0);
  const P0 = bboxCenter.clone().add(n.clone().multiplyScalar(d));
  setOffsetForPlanePassingThrough(n, P0);
}
function applySectionFromUI(){
  const mode = sectionModeSel.value;
  if(mode==="H"){
    hRow.style.display = "";
    vRow.style.display = "none";
    setHorizontalByHeightMm(heightMm.value);
  }else if(mode==="VX"){
    hRow.style.display = "none";
    vRow.style.display = "";
    setVerticalByOffsetMm("x", vOffsetMm.value);
  }else{
    hRow.style.display = "none";
    vRow.style.display = "";
    setVerticalByOffsetMm("z", vOffsetMm.value);
  }
}

/* ===== ログ ===== */
const logPanel = document.getElementById("logPanel");
const logList  = document.getElementById("logList");
let sectionLogs = [];
try{ sectionLogs = JSON.parse(localStorage.getItem("v1_6_sectionLogs")||"[]"); }catch{}
function renderLogs(){
  logList.innerHTML = "";
  sectionLogs.forEach((m,idx)=>{
    const li = document.createElement("li");
    li.style.marginBottom="4px";
    li.textContent = `#${sectionLogs.length-idx} ${new Date(m.ts).toLocaleString()} - ${m.mode} `
      + (m.mode==="H"?`H=${m.height_mm}mm`: `d=${m.center_mm}mm`)
      + ` / 周長=${m.perim} ${m.unit} / 幅=${m.width} ${m.unit} / 厚み=${m.thick} ${m.unit}`;
    logList.appendChild(li);
  });
}
renderLogs();
function pushLog(rec){
  sectionLogs.unshift(rec);
  try{ localStorage.setItem("v1_6_sectionLogs", JSON.stringify(sectionLogs)); }catch{}
  renderLogs();
}
function exportLogsCSV(){
  if(!sectionLogs.length) return;
  const rows = [["#","time","mode","height_mm","center_mm","Nx","Ny","Nz","unit","perimeter","width","thickness"]];
  const asc = [...sectionLogs].reverse();
  asc.forEach((m,i)=>{
    rows.push([i+1,new Date(m.ts).toLocaleString(),m.mode, m.height_mm??"", m.center_mm??"", m.nx, m.ny, m.nz, m.unit, m.perim, m.width, m.thick]);
  });
  const csv = rows.map(r=>r.map(s=>String(s).replace(/"/g,'""')).map(s=>/[,\"\n]/.test(s)?`"${s}"`:s).join(",")).join("\\n");
  const blob = new Blob(["\\ufeff"+csv], {type:"text/csv;charset=utf-8;"});
  const url=URL.createObjectURL(blob); const a=document.createElement("a");
  a.href=url; a.download="section-logs.csv"; document.body.appendChild(a); a.click();
  setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},0);
}
function captureNow(){
  if(selectedPolyline && (caliperWU==null||caliperDV==null)) computeCalipers();
  const u = unitSuffix();
  const perim = (selectedPerimeterRaw!=null)? Number(toDisplay(selectedPerimeterRaw).toFixed(2)) : "";
  const width = (caliperWU!=null)? Number(toDisplay(caliperWU).toFixed(2)) : "";
  const thick = (caliperDV!=null)? Number(toDisplay(caliperDV).toFixed(2)) : "";
  const mode = sectionModeSel.value;
  const rec = {
    ts: Date.now(),
    mode,
    height_mm: (mode==="H") ? Number(heightMm.value||0) : null,
    center_mm: (mode!=="H") ? Number(vOffsetMm.value||0) : null,
    nx: Number($nx.value), ny: Number($ny.value), nz: Number($nz.value),
    unit: u, perim, width, thick
  };
  pushLog(rec);
  const val = (mode==="H") ? `${rec.height_mm}mm` : `${rec.center_mm}mm`;
  const a=document.createElement("a");
  a.href=renderer.domElement.toDataURL("image/png");
  a.download = `sec_${mode}_${val}_P${perim||"na"}_${u}.png`;
  a.click();
}


/* ===== Export @Scale (Orthographic, fixed mm/px) ===== */
const expMmPerPx = document.getElementById("expMmPerPx");
const expWpx = document.getElementById("expWpx");
const expHpx = document.getElementById("expHpx");
const expMargin = document.getElementById("expMargin");
let orthoCam = new THREE.OrthographicCamera(-1,1,1,-1,0.001,10000);
function pxPerMm(){ return 1 / Math.max(0.0001, Number(expMmPerPx.value||1)); }
function exportAtScale(){
  if(!selectedPolyline){ alert("断面が未選択です。まず断面ラインをクリックしてください。"); return; }
  const W = Math.max(64, Math.floor(Number(expWpx.value||1200)));
  const H = Math.max(64, Math.floor(Number(expHpx.value||1200)));
  const marginPx = Math.max(0, Math.floor(Number(expMargin.value||0)));
  const ppm = pxPerMm(); // px per mm
  const worldPerPx = mmToModel(1/ppm); // model units per 1px
  const halfW = worldPerPx * (W/2);
  const halfH = worldPerPx * (H/2);

  // Compute basis at the plane
  const n = clippingPlane.normal.clone().normalize();
  const {u:U, v:V} = planeBasisFromNormal(n);
  const ctr = polyCenter();

  // Configure ortho frustum
  orthoCam.left = -halfW; orthoCam.right = +halfW; orthoCam.top = +halfH; orthoCam.bottom = -halfH;
  orthoCam.near = 0.001; orthoCam.far = bboxSize*50;
  const upVec = (upAxis==="u") ? U.clone() : V.clone();
  orthoCam.up.copy(upVec);
  const dist = bboxSize*2 + 1e-3;
  orthoCam.position.copy(ctr).add(n.clone().multiplyScalar(dist));
  orthoCam.lookAt(ctr);
  orthoCam.updateProjectionMatrix();

  // Warn if content overflows given fixed scale + margin
  (function warnOverflow(){
    let minU=Infinity,maxU=-Infinity,minV=Infinity,maxV=-Infinity;
    const c = ctr.clone();
    for(const p of (selectedPolyline?.points||[])){
      const d = p.clone().sub(c);
      const u = d.dot(U), v = d.dot(V);
      if(u<minU) minU=u; if(u>maxU) maxU=u;
      if(v<minV) minV=v; if(v>maxV) maxV=v;
    }
    const marginWorld = worldPerPx * marginPx;
    const needW = (maxU-minU)/2 + marginWorld;
    const needH = (maxV-minV)/2 + marginWorld;
    if(needW>halfW || needH>halfH){
      console.warn("Frame overflow at fixed scale. Increase canvas size or mm/px.");
    }
  })();

  // Render at target size (preserve current renderer size/camera)
  const oldSize = renderer.getSize(new THREE.Vector2());
  const oldPixelRatio = renderer.getPixelRatio();
  const oldCam = { pos: camera.position.clone(), up: camera.up.clone(), target: controls.target.clone(), q: camera.quaternion.clone(), near: camera.near, far: camera.far, fov: camera.fov };

  renderer.setPixelRatio(1);
  renderer.setSize(W, H);
  const prevAutoClear = renderer.autoClear;
  renderer.autoClear = true;

  // Draw with ortho camera
  renderer.render(scene, orthoCam);

  // Compose scale bar + label onto 2D canvas
  const base = renderer.domElement;
  const mix = document.createElement("canvas");
  mix.width=W; mix.height=H;
  const ctx = mix.getContext("2d");
  ctx.drawImage(base,0,0);

  // Scale bar: 100mm (or shorter if too wide)
  let barMm = 100;
  const px100 = Math.floor(barMm * ppm);
  let barPx = Math.min(px100, Math.floor(W*0.35));
  barMm = Math.round(barPx / ppm);
  const m = 14; // margin in px
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(m, H-m-26, barPx+12, 24);
  ctx.fillStyle = "white";
  ctx.fillRect(m+6, H-m-18, barPx, 6);
  ctx.font = "12px system-ui, sans-serif";
  ctx.fillText(`${barMm} mm  @ ${Number(expMmPerPx.value)} mm/px`, m+6, H-m-24);

  // Save
  const url = mix.toDataURL("image/png");
  const a=document.createElement("a");
  const u = unitSuffix();
  const perim = (selectedPerimeterRaw!=null)? Number(toDisplay(selectedPerimeterRaw).toFixed(2)) : "";
  const mode = sectionModeSel.value;
  const val = (mode==='H') ? `${Number(heightMm.value||0)}mm` : `${Number(vOffsetMm.value||0)}mm`;
  a.href=url; a.download=`export_scale_${mode}_${val}_P${perim||"na"}_${u}_${W}x${H}.png`; a.click();

  // Restore renderer & camera
  renderer.setSize(oldSize.x, oldSize.y);
  renderer.setPixelRatio(oldPixelRatio);
  renderer.autoClear = prevAutoClear;
  camera.position.copy(oldCam.pos); camera.up.copy(oldCam.up); camera.near=oldCam.near; camera.far=oldCam.far; camera.fov=oldCam.fov; camera.quaternion.copy(oldCam.q); camera.updateProjectionMatrix(); controls.target.copy(oldCam.target); controls.update();
}
document.getElementById("exportScaleBtn").addEventListener("click", exportAtScale);

/* ===== UI ===== */
document.getElementById("wireBtn").addEventListener("click",()=>{ setWireframe(!isWire); });
document.getElementById("clipBtn").addEventListener("click",()=>{ clipEnabled=!clipEnabled; applyClippingToMeshes(clipEnabled); document.getElementById("clipBtn").textContent="Clip Mesh: "+(clipEnabled?"ON":"OFF"); });
document.getElementById("resetBtn").addEventListener("click",resetToHome);
document.getElementById("saveBtn").addEventListener("click",()=>{ const a=document.createElement("a"); a.href=renderer.domElement.toDataURL("image/png"); a.download="section.png"; a.click(); });
document.getElementById("captureBtn").addEventListener("click", captureNow);
document.getElementById("rebuildBtn").addEventListener("click",()=>rebuildSection());
document.getElementById("caliperBtn").addEventListener("click",()=>computeCalipers());
document.getElementById("snapModeBtn").addEventListener("click",()=>{ snapMode=(snapMode==="auto"?"u":snapMode==="u"?"v":snapMode==="v"?"off":"auto"); document.getElementById("snapModeBtn").textContent="Snap: "+snapMode.toUpperCase(); });

document.getElementById("alignYBtn").addEventListener("click",()=>{ setNormalExact(0,1,0); sectionModeSel.value="H"; applySectionFromUI(); });
document.getElementById("alignXBtn").addEventListener("click",()=>{ setNormalExact(1,0,0); sectionModeSel.value="VX"; applySectionFromUI(); });
document.getElementById("alignZBtn").addEventListener("click",()=>{ setNormalExact(0,0,1); sectionModeSel.value="VZ"; applySectionFromUI(); });

document.getElementById("viewOnPlaneBtn").addEventListener("click",()=>alignViewToPlane());
document.getElementById("flipViewBtn").addEventListener("click",()=>{ viewSide = (viewSide===1?-1:1); alignViewToPlane(); });
document.getElementById("upAxisBtn").addEventListener("click",()=>{ upAxis = (upAxis==="u"?"v":"u"); document.getElementById("upAxisBtn").textContent = "Up Axis: "+(upAxis.toUpperCase()); alignViewToPlane(); });
document.getElementById("soloBtn").addEventListener("click",()=>{ applySoloMode(!soloMode); document.getElementById("soloBtn").textContent = "Solo View: "+(soloMode?"ON":"OFF"); });

document.getElementById("off0Btn").addEventListener("click",()=>{ $offset.value="0"; updatePlane(); });
document.getElementById("offMinusBtn").addEventListener("click",()=>offsetStep(-0.01));
document.getElementById("offPlusBtn").addEventListener("click",()=>offsetStep(+0.01));

[$nx,$ny,$nz,$offset].forEach(el=>el.addEventListener("input", updatePlane));
unitSel.addEventListener("change",()=>{ updateHUD(); applySectionFromUI(); });
modelUnitSel.addEventListener("change",()=>{ updateHUD(); applySectionFromUI(); });

/* Rotate */
document.getElementById("rotXp").addEventListener("click",()=>{ root.rotation.x += Math.PI/2; fitView(root); applySectionFromUI(); });
document.getElementById("rotXm").addEventListener("click",()=>{ root.rotation.x -= Math.PI/2; fitView(root); applySectionFromUI(); });
document.getElementById("rotYp").addEventListener("click",()=>{ root.rotation.y += Math.PI/2; fitView(root); applySectionFromUI(); });
document.getElementById("rotYm").addEventListener("click",()=>{ root.rotation.y -= Math.PI/2; fitView(root); applySectionFromUI(); });
document.getElementById("rotZp").addEventListener("click",()=>{ root.rotation.z += Math.PI/2; fitView(root); applySectionFromUI(); });
document.getElementById("rotZm").addEventListener("click",()=>{ root.rotation.z -= Math.PI/2; fitView(root); applySectionFromUI(); });
document.getElementById("rotReset").addEventListener("click",()=>{ root.rotation.set(0,0,0); fitView(root); applySectionFromUI(); });

/* Section */
sectionModeSel.addEventListener("change", applySectionFromUI);
groundBtn.addEventListener("click",()=>{ groundY = bboxMin.y; applySectionFromUI(); });
applyHeightBtn.addEventListener("click", applySectionFromUI);
applyVBtn.addEventListener("click", applySectionFromUI);
heightMm.addEventListener("change", applySectionFromUI);
vOffsetMm.addEventListener("change", applySectionFromUI);

/* Log UI */
document.getElementById("logToggleBtn").addEventListener("click",()=>{ const on = logPanel.style.display!=="none"; logPanel.style.display = on?"none":"block"; document.getElementById("logToggleBtn").textContent = "Log: "+(on?"OFF":"ON"); });
document.getElementById("logCsvBtn").addEventListener("click", exportLogsCSV);
document.getElementById("logClearBtn").addEventListener("click",()=>{ sectionLogs=[]; try{localStorage.setItem("v1_6_sectionLogs","[]");}catch{}; renderLogs(); });

addEventListener("pointerdown", onPointerDown);
addEventListener("keydown",(e)=>{ if(e.key==="Escape") clearPicks(); });
addEventListener("resize",()=>{ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); updatePerimLabelPosition(); updateCaliperLabelPosition(); setHUDTop(); });

/* D&D */
const drop=document.getElementById("drop");
["dragenter","dragover"].forEach(ev=>document.addEventListener(ev,(e)=>{e.preventDefault(); drop.classList.add("show");}));
["dragleave","drop"].forEach(ev=>document.addEventListener(ev,(e)=>{e.preventDefault(); if(ev==="drop"){ const files=[...e.dataTransfer.files]; if(files.length){ clearRoot(); clearSections(); clearOverlay(); applySoloMode(false); let pending=files.length; const done=()=>{ if(--pending===0) { fitView(root); applySectionFromUI(); } }; files.forEach(f=>{ const url=URL.createObjectURL(f); const ext=f.name.toLowerCase().split('.').pop(); loadSingle(url,ext,done); }); } } drop.classList.remove("show");}));

/* 初期化 */
saveHomeFromCurrent();
setHUDTop();
(function render(){ controls.update(); renderer.render(scene,camera); if(selectedPolyline){ updatePerimLabelPosition(); updateCaliperLabelPosition(); } requestAnimationFrame(render); })();
</script>
</body>
</html>
